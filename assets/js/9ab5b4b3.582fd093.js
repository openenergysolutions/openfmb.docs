(window.webpackJsonp=window.webpackJsonp||[]).push([[33],{104:function(e,t,i){"use strict";i.r(t),i.d(t,"frontMatter",(function(){return l})),i.d(t,"metadata",(function(){return s})),i.d(t,"toc",(function(){return o})),i.d(t,"default",(function(){return _}));var n=i(3),r=i(8),a=(i(0),i(133)),l={},s={unversionedId:"adapter/protocol-plugins/modbus/master",id:"adapter/protocol-plugins/modbus/master",isDocsHomePage:!1,title:"Modbus Master",description:"The modbus-master plugin acts as a Modbus client (master) that can read and",source:"@site/docs/adapter/protocol-plugins/modbus/master.md",sourceDirName:"adapter/protocol-plugins/modbus",slug:"/adapter/protocol-plugins/modbus/master",permalink:"/openfmb.docs/docs/adapter/protocol-plugins/modbus/master",editUrl:"https://github.com/openenergysolutions/openfmb.docs/edit/develop/website/docs/adapter/protocol-plugins/modbus/master.md",version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"DDS",permalink:"/openfmb.docs/docs/adapter/native-plugins/dds"},next:{title:"Modbus Outstation",permalink:"/openfmb.docs/docs/adapter/protocol-plugins/modbus/outstation"}},o=[{value:"General configuration",id:"general-configuration",children:[{value:"Heartbeat",id:"heartbeat",children:[]}]},{value:"Non-control profiles",id:"non-control-profiles",children:[{value:"Configuration",id:"configuration",children:[]},{value:"Boolean",id:"boolean",children:[]},{value:"Int32, Int64 and Float",id:"int32-int64-and-float",children:[]},{value:"Enum",id:"enum",children:[]}]},{value:"Control profiles",id:"control-profiles",children:[{value:"Configuration",id:"configuration-1",children:[]},{value:"Boolean",id:"boolean-1",children:[]},{value:"Int32, Int64 and Float",id:"int32-int64-and-float-1",children:[]},{value:"Enum",id:"enum-1",children:[]},{value:"Schedule parameters",id:"schedule-parameters",children:[]}]}],p={toc:o};function _(e){var t=e.components,i=Object(r.a)(e,["components"]);return Object(a.b)("wrapper",Object(n.a)({},p,i,{components:t,mdxType:"MDXLayout"}),Object(a.b)("p",null,"The ",Object(a.b)("inlineCode",{parentName:"p"},"modbus-master")," plugin acts as a Modbus client (master) that can read and\nwrite Modbus coils, discrete inputs, input registers and holding registers."),Object(a.b)("p",null,"The adapter automatically determines what to poll based on the types and indices\nreferenced in detailed mapping."),Object(a.b)("h2",{id:"general-configuration"},"General configuration"),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},Object(a.b)("inlineCode",{parentName:"li"},"session"),": name used in the logs"),Object(a.b)("li",{parentName:"ul"},Object(a.b)("inlineCode",{parentName:"li"},"log-level"),": protocol log level to print to the logs"),Object(a.b)("li",{parentName:"ul"},Object(a.b)("inlineCode",{parentName:"li"},"remote-ip"),": IP of the device to connect to"),Object(a.b)("li",{parentName:"ul"},Object(a.b)("inlineCode",{parentName:"li"},"port"),": port of the device to connect to (usually 502)"),Object(a.b)("li",{parentName:"ul"},Object(a.b)("inlineCode",{parentName:"li"},"unit-identifier"),": Modbus unit identifier of the device to connect to"),Object(a.b)("li",{parentName:"ul"},Object(a.b)("inlineCode",{parentName:"li"},"response_timeout_ms"),": timeout value in milliseconds for responses"),Object(a.b)("li",{parentName:"ul"},Object(a.b)("inlineCode",{parentName:"li"},"always-write-multiple-registers"),": when set to ",Object(a.b)("inlineCode",{parentName:"li"},"true"),', even if only a single\nregister must be written, a "Write Multiple Registers" (0x10) is used.'),Object(a.b)("li",{parentName:"ul"},Object(a.b)("inlineCode",{parentName:"li"},"auto_polling"),": when deciding what polling requests are needed to get all the\nnecessary values, this parameter configures the number of unnecessary values\nwe are willing to accept for the benefit of fewer Modbus requests. A value of\n",Object(a.b)("inlineCode",{parentName:"li"},"0")," means absolutely no unnecessary registers will be polled.",Object(a.b)("ul",{parentName:"li"},Object(a.b)("li",{parentName:"ul"},Object(a.b)("inlineCode",{parentName:"li"},"auto_polling.max_bit_gaps"),": maximum number of unnecessary bits that can\nbe read when polling for coils and discrete inputs."),Object(a.b)("li",{parentName:"ul"},Object(a.b)("inlineCode",{parentName:"li"},"auto_polling.max_register_gaps"),": maximum number of unnecessary registers\nthat can be read when polling for holding and input registers.")))),Object(a.b)("h3",{id:"heartbeat"},"Heartbeat"),Object(a.b)("p",null,"Some devices require a periodic heartbeat message to remain in a remotely\nmanaged mode. Typically, a specific register must be read, some bits inverted\nand written back. The adapter can handle this functionality with the\n",Object(a.b)("inlineCode",{parentName:"p"},"heartbeats")," configuration parameter. A list of indices to perform the heartbeat\non is specified, as well as the period and the mask to use for inverting the\nbits. Here is an example for a device with a single heartbeat register:"),Object(a.b)("pre",null,Object(a.b)("code",{parentName:"pre",className:"language-yaml"},"heartbeats:\n  - index: 7  # Read the specified register, invert the masked bits, and write it back\n    period_ms: 1000  # Heartbeat period in milliseconds\n    mask: 0x1  # Mask specifying the bits to invert\n")),Object(a.b)("h2",{id:"non-control-profiles"},"Non-control profiles"),Object(a.b)("p",null,"The non-control profiles can map Modbus coils, input, and holding registers to\nan OpenFMB message values."),Object(a.b)("h3",{id:"configuration"},"Configuration"),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},Object(a.b)("inlineCode",{parentName:"li"},"poll_period_ms"),": specify the number of milliseconds between two polls")),Object(a.b)("h3",{id:"boolean"},"Boolean"),Object(a.b)("p",null,"Boolean values can be retrieved from coils and discrete inputs. Optionally, the\nvalue can be inverted."),Object(a.b)("p",null,"Boolean values may also be retrieved from holding registers and input registers.\nA mask is applied to the register value. If the value is not equal to 0, the\nboolean is ",Object(a.b)("inlineCode",{parentName:"p"},"true"),", otherwise it's ",Object(a.b)("inlineCode",{parentName:"p"},"false"),". It is possible to add an ",Object(a.b)("inlineCode",{parentName:"p"},"invert:\ntrue")," parameter. In that case, if the masked value is different than 0, the\nboolean is ",Object(a.b)("inlineCode",{parentName:"p"},"false"),", otherwise it's ",Object(a.b)("inlineCode",{parentName:"p"},"true"),"."),Object(a.b)("pre",null,Object(a.b)("code",{parentName:"pre",className:"language-yaml",metastring:'tab="coil"',tab:'"coil"'},"bool-field-type: mapped\nsource-type: holding_register  # {none, coil, discrete_input, holding_register, input_register}\nindex: 10\ninvert: false  # invert the boolean value.\n")),Object(a.b)("pre",null,Object(a.b)("code",{parentName:"pre",className:"language-yaml",metastring:'tab="discrete_input"',tab:'"discrete_input"'},"bool-field-type: mapped\nsource-type: discrete_input  # {none, coil, discrete_input, holding_register, input_register}\nindex: 11\ninvert: true  # invert the boolean value.\n")),Object(a.b)("pre",null,Object(a.b)("code",{parentName:"pre",className:"language-yaml",metastring:'tab="holding_register"',tab:'"holding_register"'},"bool-field-type: mapped\nsource-type: holding_register  # {none, coil, discrete_input, holding_register, input_register}\nindex: 13\nmask: 0x0001  # mask the register. true if masked value != 0\ninvert: false  # invert the boolean value.\n")),Object(a.b)("pre",null,Object(a.b)("code",{parentName:"pre",className:"language-yaml",metastring:'tab="input_register"',tab:'"input_register"'},"bool-field-type: mapped\nsource-type: input_register  # {none, coil, discrete_input, holding_register, input_register}\nindex: 14\nmask: 0x0004  # mask the register. true if masked value != 0\ninvert: true  # invert the boolean value.\n")),Object(a.b)("h3",{id:"int32-int64-and-float"},"Int32, Int64 and Float"),Object(a.b)("p",null,"Int32, Int64 and Float values can be retrieved from holding registers and input\nregisters. The ",Object(a.b)("inlineCode",{parentName:"p"},"source-type")," field determines what type of registers must be\nread."),Object(a.b)("p",null,"There are multiple mapping types that can be used to derive the value. All of\nthe mapping types can be scaled."),Object(a.b)("p",null,"All 16-bit mapping types require a single holding register, so a single ",Object(a.b)("inlineCode",{parentName:"p"},"index"),"\nvalue is needed. All 32-bit mapping types require two indices. The ",Object(a.b)("inlineCode",{parentName:"p"},"lower_index"),"\nidentifies the register containing the two least significant bytes (LSBs). The\n",Object(a.b)("inlineCode",{parentName:"p"},"upper_index")," identifies the register containing the two most significant bytes\n(MSBs). For example, if the 32-bit value that needs to be written is\n",Object(a.b)("inlineCode",{parentName:"p"},"0xAABBCCDD")," and you set the ",Object(a.b)("inlineCode",{parentName:"p"},"lower_index")," to 10 and ",Object(a.b)("inlineCode",{parentName:"p"},"upper_index")," to 11, then\n",Object(a.b)("inlineCode",{parentName:"p"},"0xCCDD")," would be written to register 10 and ",Object(a.b)("inlineCode",{parentName:"p"},"0xAABB")," would be written to\nregister 11. If ",Object(a.b)("inlineCode",{parentName:"p"},"lower_index")," is 11 and ",Object(a.b)("inlineCode",{parentName:"p"},"upper_index")," is 10, then ",Object(a.b)("inlineCode",{parentName:"p"},"0xAABB")," would\nbe written to register 10 and ",Object(a.b)("inlineCode",{parentName:"p"},"0xCCDD")," would be written to register 11."),Object(a.b)("p",null,'The mapping types starting with an "s" means they are signed (they are two\'s\ncomplement integers). The mapping types starting with a "u" are unsigned.'),Object(a.b)("p",null,'The "with_modulus" mappings take an extra ',Object(a.b)("inlineCode",{parentName:"p"},"modulus")," parameter and allow for\nscaling the MSB register using a value other than 65536. Most users will never\nuse this as it was added to accomodate a peculiar device."),Object(a.b)("p",null,'The "float" type reads an IEEE 754 floating-point value from two registers.'),Object(a.b)("pre",null,Object(a.b)("code",{parentName:"pre",className:"language-yaml",metastring:'tab="sint16"',tab:'"sint16"'},"float-field-type: mapped\nsource-type: holding_register  # {none, holding_register, input_register}\nregister-mapping: sint32  # {sint16, uint16, sint32, uint32, sint32_with_modulus, uint32_with_modulus, float32}\nindex: 10\nscale: 1\n")),Object(a.b)("pre",null,Object(a.b)("code",{parentName:"pre",className:"language-yaml",metastring:'tab="uint16"',tab:'"uint16"'},"float-field-type: mapped\nsource-type: input_register  # {none, holding_register, input_register}\nregister-mapping: uint16  # {sint16, uint16, sint32, uint32, sint32_with_modulus, uint32_with_modulus, float32}\nindex: 10\nscale: 1\n")),Object(a.b)("pre",null,Object(a.b)("code",{parentName:"pre",className:"language-yaml",metastring:'tab="sint32"',tab:'"sint32"'},"float-field-type: mapped\nsource-type: holding_register  # {none, holding_register, input_register}\nregister-mapping: sint32  # {sint16, uint16, sint32, uint32, sint32_with_modulus, uint32_with_modulus, float32}\nlower_index: 0\nupper_index: 1\nscale: 1\n")),Object(a.b)("pre",null,Object(a.b)("code",{parentName:"pre",className:"language-yaml",metastring:'tab="uint32"',tab:'"uint32"'},"float-field-type: mapped\nsource-type: input_register  # {none, holding_register, input_register}\nregister-mapping: uint32  # {sint16, uint16, sint32, uint32, sint32_with_modulus, uint32_with_modulus, float32}\nlower_index: 0\nupper_index: 1\nscale: 1\n")),Object(a.b)("pre",null,Object(a.b)("code",{parentName:"pre",className:"language-yaml",metastring:'tab="sint32_with_modulus"',tab:'"sint32_with_modulus"'},"float-field-type: mapped\nsource-type: holding_register  # {none, holding_register, input_register}\nregister-mapping: sint32_with_modulus  # {sint16, uint16, sint32, uint32, sint32_with_modulus, uint32_with_modulus, float32}\nlower_index: 0\nupper_index: 1\nmodulus: 10000\nscale: 1\n")),Object(a.b)("pre",null,Object(a.b)("code",{parentName:"pre",className:"language-yaml",metastring:'tab="uint32_with_modulus"',tab:'"uint32_with_modulus"'},"float-field-type: mapped\nsource-type: input_register  # {none, holding_register, input_register}\nregister-mapping: uint32_with_modulus  # {sint16, uint16, sint32, uint32, sint32_with_modulus, uint32_with_modulus, float32}\nlower_index: 0\nupper_index: 1\nmodulus: 10000\nscale: 1\n")),Object(a.b)("pre",null,Object(a.b)("code",{parentName:"pre",className:"language-yaml",metastring:'tab="float32"',tab:'"float32"'},"float-field-type: mapped\nsource-type: holding_register  # {none, holding_register, input_register}\nregister-mapping: float32  # {sint16, uint16, sint32, uint32, sint32_with_modulus, uint32_with_modulus, float32}\nlower_index: 0\nupper_index: 1\nscale: 1\n")),Object(a.b)("h3",{id:"enum"},"Enum"),Object(a.b)("p",null,"Enums can be retrieved from one or more registers."),Object(a.b)("p",null,"When retrieved from a single register, a mask is applied and each enum value is\nassociated with a register value."),Object(a.b)("p",null,"When multiple registers are used, a list of indices and bit position is\nspecified. The adapter will poll the the appropriate register and update a\nvirtual value with each specified bit. Then, a list of pattern is specified\nwhere each bit pattern is associated with an enum value."),Object(a.b)("p",null,"Enums can also be mapped from coils and discrete inputs. A enum value is\nassociated when the bit is ",Object(a.b)("inlineCode",{parentName:"p"},"true")," and another value is associated when the bit\nis ",Object(a.b)("inlineCode",{parentName:"p"},"false"),"."),Object(a.b)("pre",null,Object(a.b)("code",{parentName:"pre",className:"language-yaml",metastring:'tab="single_bit"',tab:'"single_bit"'},"enum-field-type: mapped\nsource-type: coil  # {none, coil, discrete_input, holding_register, input_register}\nenum-mapping-type: single_bit  # {none, single_bit, single_register, multiple_register}\nindex: 10\nwhen-true: DynamicTestKind_operating\nwhen-false: DynamicTestKind_none\n")),Object(a.b)("pre",null,Object(a.b)("code",{parentName:"pre",className:"language-yaml",metastring:'tab="single_register"',tab:'"single_register"'},"enum-field-type: mapped\nsource-type: holding_register  # {none, coil, discrete_input, holding_register, input_register}\nenum-mapping-type: single_register  # {none, single_bit, single_register, multiple_register}\nindex: 10\nmask: 0x0003  # mask the register. map masked values to enum values\nmapping:\n  - name: DynamicTestKind_none\n    value: 0\n  - name: DynamicTestKind_testing\n    value: 1\n  - name: DynamicTestKind_operating\n    value: 2\n  - name: DynamicTestKind_failed\n    value: 3\n")),Object(a.b)("pre",null,Object(a.b)("code",{parentName:"pre",className:"language-yaml",metastring:'tab="multiple_register"',tab:'"multiple_register"'},'enum-field-type: mapped\nsource-type: input_register  # {none, coil, discrete_input, holding_register, input_register}\nenum-mapping-type: multiple_register  # {none, single_bit, single_register, multiple_register}\nbits:\n  - index: 10\n    bit: 0\n  - index: 10\n    bit: 1\nmapping:\n  - pattern: "0000000000000001"\n    value: DynamicTestKind_none\n')),Object(a.b)("h2",{id:"control-profiles"},"Control profiles"),Object(a.b)("p",null,"Control profiles can be translated to Modbus write requests."),Object(a.b)("h3",{id:"configuration-1"},"Configuration"),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},Object(a.b)("inlineCode",{parentName:"li"},"poll_period_ms"),": specify the number of milliseconds between two polls"),Object(a.b)("li",{parentName:"ul"},Object(a.b)("inlineCode",{parentName:"li"},"command-order"),": ordered list of ",Object(a.b)("inlineCode",{parentName:"li"},"command-id"),". The first ID has the highest\npriority."),Object(a.b)("li",{parentName:"ul"},Object(a.b)("inlineCode",{parentName:"li"},"tolerance-ms"),": number of milliseconds of tolerance for schedules.")),Object(a.b)("h3",{id:"boolean-1"},"Boolean"),Object(a.b)("p",null,"For boolean fields, a ",Object(a.b)("inlineCode",{parentName:"p"},"when-true")," list of actions to perform when the boolean\nvalue is ",Object(a.b)("inlineCode",{parentName:"p"},"true")," is specified. Likewise, a ",Object(a.b)("inlineCode",{parentName:"p"},"when-false")," list of actions to\nperform when the boolean value is ",Object(a.b)("inlineCode",{parentName:"p"},"false")," is specified."),Object(a.b)("p",null,"Each action requires a ",Object(a.b)("inlineCode",{parentName:"p"},"command-id")," for prioritization of the commands. The name\nmust fit with one the values in the ",Object(a.b)("inlineCode",{parentName:"p"},"command-order")," array."),Object(a.b)("p",null,"Multiple ",Object(a.b)("inlineCode",{parentName:"p"},"output-type")," are available. The ",Object(a.b)("inlineCode",{parentName:"p"},"write_single_coil")," takes an index and\na boolean value and writes it to the coil. The ",Object(a.b)("inlineCode",{parentName:"p"},"flip_single_coil")," only takes an\nindex and performs a read followed by a write to flip the coil value."),Object(a.b)("pre",null,Object(a.b)("code",{parentName:"pre",className:"language-yaml",metastring:'tab="write_single_coil"',tab:'"write_single_coil"'},"output-type: write_single_coil  # {none, write_single_coil, flip_single_coil, write_single_register_uint16, write_single_register_int16, write_multiple_registers_uint32, write_multiple_registers_int32, write_multiple_registers_float32, read_and_modify_register}\ncommand-id: some-command-id\nindex: 10\nvalue: true\n")),Object(a.b)("pre",null,Object(a.b)("code",{parentName:"pre",className:"language-yaml",metastring:'tab="flip_single_coil"',tab:'"flip_single_coil"'},"output-type: flip_single_coil  # {none, write_single_coil, flip_single_coil, write_single_register_uint16, write_single_register_int16, write_multiple_registers_uint32, write_multiple_registers_int32, write_multiple_registers_float32, read_and_modify_register}\ncommand-id: some-command-id\nindex: 11\n")),Object(a.b)("p",null,"The ",Object(a.b)("inlineCode",{parentName:"p"},"write_single_register_*")," ones take an index and a value, and write that\nvalue to a single holding register. The ",Object(a.b)("inlineCode",{parentName:"p"},"write_multiple_registers_*")," takes\ntwo indices and a value, and write that value into the two holding registers.\n",Object(a.b)("inlineCode",{parentName:"p"},"lower_index")," will contain the two LSB and ",Object(a.b)("inlineCode",{parentName:"p"},"upper_index")," will contain the two\nMSB."),Object(a.b)("pre",null,Object(a.b)("code",{parentName:"pre",className:"language-yaml",metastring:'tab="write_single_register_uint16"',tab:'"write_single_register_uint16"'},"output-type: write_single_register_uint16  # {none, write_single_coil, flip_single_coil, write_single_register_uint16, write_single_register_int16, write_multiple_registers_uint32, write_multiple_registers_int32, write_multiple_registers_float32, read_and_modify_register}\ncommand-id: some-command-id\nindex: 12\nvalue: 42\n")),Object(a.b)("pre",null,Object(a.b)("code",{parentName:"pre",className:"language-yaml",metastring:'tab="write_single_register_int16"',tab:'"write_single_register_int16"'},"output-type: write_single_register_int16  # {none, write_single_coil, flip_single_coil, write_single_register_uint16, write_single_register_int16, write_multiple_registers_uint32, write_multiple_registers_int32, write_multiple_registers_float32, read_and_modify_register}\ncommand-id: some-command-id\nindex: 13\nvalue: 76\n")),Object(a.b)("pre",null,Object(a.b)("code",{parentName:"pre",className:"language-yaml",metastring:'tab="write_multiple_registers_uint32"',tab:'"write_multiple_registers_uint32"'},"output-type: write_multiple_registers_uint32  # {none, write_single_coil, flip_single_coil, write_single_register_uint16, write_single_register_int16, write_multiple_registers_uint32, write_multiple_registers_int32, write_multiple_registers_float32, read_and_modify_register}\ncommand-id: some-command-id\nlower_index: 1000\nupper_index: 1001\nvalue: 42\n")),Object(a.b)("pre",null,Object(a.b)("code",{parentName:"pre",className:"language-yaml",metastring:'tab="write_multiple_registers_int32"',tab:'"write_multiple_registers_int32"'},"output-type: write_multiple_registers_int32  # {none, write_single_coil, flip_single_coil, write_single_register_uint16, write_single_register_int16, write_multiple_registers_uint32, write_multiple_registers_int32, write_multiple_registers_float32, read_and_modify_register}\ncommand-id: some-command-id\nlower_index: 1002\nupper_index: 1003\nvalue: 42\n")),Object(a.b)("pre",null,Object(a.b)("code",{parentName:"pre",className:"language-yaml",metastring:'tab="write_multiple_registers_float32"',tab:'"write_multiple_registers_float32"'},"output-type: write_multiple_registers_float32  # {none, write_single_coil, flip_single_coil, write_single_register_uint16, write_single_register_int16, write_multiple_registers_uint32, write_multiple_registers_int32, write_multiple_registers_float32, read_and_modify_register}\ncommand-id: some-command-id\nlower_index: 1004\nupper_index: 1005\nvalue: 42\n")),Object(a.b)("p",null,"The ",Object(a.b)("inlineCode",{parentName:"p"},"read_and_modify_register")," output type can be used to do masked operation on\nthe register value. It takes an extra ",Object(a.b)("inlineCode",{parentName:"p"},"bitwise-operation")," parameter that\ndescribes the operation to perform, as well as a mask or a bit position.\nHere are all the ",Object(a.b)("inlineCode",{parentName:"p"},"bitwise-operation")," supported:"),Object(a.b)("pre",null,Object(a.b)("code",{parentName:"pre",className:"language-yaml",metastring:'tab="set_bit"',tab:'"set_bit"'},"output-type: read_and_modify_register  # {none, write_single_coil, flip_single_coil, write_single_register_uint16, write_single_register_int16, write_multiple_registers_uint32, write_multiple_registers_int32, write_multiple_registers_float32, read_and_modify_register}\ncommand-id: some-command-id\nbitwise-operation: set_bit  # {set_bit, clear_bit, clear_masked_bits, set_masked_bits}\nindex: 10\nbit: 0\n")),Object(a.b)("pre",null,Object(a.b)("code",{parentName:"pre",className:"language-yaml",metastring:'tab="clear_bit"',tab:'"clear_bit"'},"output-type: read_and_modify_register  # {none, write_single_coil, flip_single_coil, write_single_register_uint16, write_single_register_int16, write_multiple_registers_uint32, write_multiple_registers_int32, write_multiple_registers_float32, read_and_modify_register}\ncommand-id: some-command-id\nbitwise-operation: clear_bit  # {set_bit, clear_bit, clear_masked_bits, set_masked_bits}\nindex: 10\nbit: 0\n")),Object(a.b)("pre",null,Object(a.b)("code",{parentName:"pre",className:"language-yaml",metastring:'tab="set_masked_bits"',tab:'"set_masked_bits"'},"output-type: read_and_modify_register  # {none, write_single_coil, flip_single_coil, write_single_register_uint16, write_single_register_int16, write_multiple_registers_uint32, write_multiple_registers_int32, write_multiple_registers_float32, read_and_modify_register}\ncommand-id: some-command-id\nbitwise-operation: set_masked_bits  # {set_bit, clear_bit, clear_masked_bits, set_masked_bits}\nindex: 10\nmask: 0x0F\n")),Object(a.b)("pre",null,Object(a.b)("code",{parentName:"pre",className:"language-yaml",metastring:'tab="clear_masked_bits"',tab:'"clear_masked_bits"'},"output-type: read_and_modify_register # {none, write_single_coil, flip_single_coil, write_single_register_uint16, write_single_register_int16, write_multiple_registers_uint32, write_multiple_registers_int32, write_multiple_registers_float32, read_and_modify_register}\ncommand-id: some-command-id\nbitwise-operation: clear_masked_bits  # {set_bit, clear_bit, clear_masked_bits, set_masked_bits}\nindex: 10\nmask: 0x0F\n")),Object(a.b)("p",null,"Here is an example of a valid configuration:"),Object(a.b)("pre",null,Object(a.b)("code",{parentName:"pre",className:"language-yaml"},"bool-field-type: mapped\nwhen-true:\n  - output-type: write_single_register_uint16  # {none, write_single_coil, flip_single_coil, write_single_register_uint16, write_single_register_int16, write_multiple_registers_uint32, write_multiple_registers_int32, write_multiple_registers_float32, read_and_modify_register}\n    command-id: some-command-id\n    index: 10\n    value: 42\nwhen-false:\n  - output-type: read_and_modify_register  # {none, write_single_coil, flip_single_coil, write_single_register_uint16, write_single_register_int16, write_multiple_registers_uint32, write_multiple_registers_int32, write_multiple_registers_float32, read_and_modify_register}\n    command-id: some-command-id\n    bitwise-operation: set_masked_bits  # {set_bit, clear_bit, clear_masked_bits, set_masked_bits}\n    index: 11\n    mask: 0x0F\n")),Object(a.b)("h3",{id:"int32-int64-and-float-1"},"Int32, Int64 and Float"),Object(a.b)("p",null,"Int32, Int64 and Float values can be converted to values written to one or\nmultiple Modbus registers. When writing to multiple registers, ",Object(a.b)("inlineCode",{parentName:"p"},"lower_index"),"\nwill contain the two LSB, and ",Object(a.b)("inlineCode",{parentName:"p"},"upper_index")," will contain the two MSB. Scaling\ncan be applied on all types."),Object(a.b)("p",null,"The ",Object(a.b)("inlineCode",{parentName:"p"},"write_multiple_registers_float32")," writes the IEEE 754 floating-point\nrepresentation of the value to the register."),Object(a.b)("pre",null,Object(a.b)("code",{parentName:"pre",className:"language-yaml",metastring:'tab="write_single_register_uint16"',tab:'"write_single_register_uint16"'},"float-field-type: mapped\noutput-type: write_single_register_uint16  # {none, write_single_register_uint16, write_single_register_int16, write_multiple_registers_uint32, write_multiple_registers_int32, write_multiple_registers_float32}\ncommand-id: some-command-id\nindex: 10\nscale: 1\n")),Object(a.b)("pre",null,Object(a.b)("code",{parentName:"pre",className:"language-yaml",metastring:'tab="write_single_register_int16"',tab:'"write_single_register_int16"'},"float-field-type: mapped\noutput-type: write_single_register_int16  # {none, write_single_register_uint16, write_single_register_int16, write_multiple_registers_uint32, write_multiple_registers_int32, write_multiple_registers_float32}\ncommand-id: some-command-id\nindex: 10\nscale: 1\n")),Object(a.b)("pre",null,Object(a.b)("code",{parentName:"pre",className:"language-yaml",metastring:'tab="write_multiple_registers_uint32"',tab:'"write_multiple_registers_uint32"'},"float-field-type: mapped\noutput-type: write_multiple_registers_uint32  # {none, write_single_register_uint16, write_single_register_int16, write_multiple_registers_uint32, write_multiple_registers_int32, write_multiple_registers_float32}\ncommand-id: some-command-id\nupper_index: 10\nlower_index: 11\nscale: 1\n")),Object(a.b)("pre",null,Object(a.b)("code",{parentName:"pre",className:"language-yaml",metastring:'tab="write_multiple_registers_int32"',tab:'"write_multiple_registers_int32"'},"float-field-type: mapped\noutput-type: write_multiple_registers_int32  # {none, write_single_register_uint16, write_single_register_int16, write_multiple_registers_uint32, write_multiple_registers_int32, write_multiple_registers_float32}\ncommand-id: some-command-id\nupper_index: 10\nlower_index: 11\nscale: 1\n")),Object(a.b)("pre",null,Object(a.b)("code",{parentName:"pre",className:"language-yaml",metastring:'tab="write_multiple_registers_float32"',tab:'"write_multiple_registers_float32"'},"float-field-type: mapped\noutput-type: write_multiple_registers_float32  # {none, write_single_register_uint16, write_single_register_int16, write_multiple_registers_uint32, write_multiple_registers_int32, write_multiple_registers_float32}\ncommand-id: some-command-id\nupper_index: 10\nlower_index: 11\nscale: 1\n")),Object(a.b)("h3",{id:"enum-1"},"Enum"),Object(a.b)("p",null,"For each enum variant, a list of actions are specified. The syntax and usage is\nthe exact same as the ",Object(a.b)("a",{parentName:"p",href:"#boolean"},"Boolean")," values. Here is an example of a\nvalid configuration:"),Object(a.b)("pre",null,Object(a.b)("code",{parentName:"pre",className:"language-yaml"},"enum-field-type: mapped\nmapping:\n  - name: StateKind_off\n    outputs:\n      - output-type: read_and_modify_register  # {none, write_single_coil, flip_single_coil, write_single_register_uint16, write_single_register_int16, write_multiple_registers_uint32, write_multiple_registers_int32, write_multiple_registers_float32, read_and_modify_register}\n        command-id: some-command-id\n        bitwise-operation: read_and_modify_register  # {set_bit, clear_bit, clear_masked_bits, set_masked_bits}\n        index: 0\n        mask: 0x0F\n  - name: StateKind_on\n    outputs:\n      - output-type: read_and_modify_register  # {none, write_single_coil, flip_single_coil, write_single_register_uint16, write_single_register_int16, write_multiple_registers_uint32, write_multiple_registers_int32, write_multiple_registers_float32, read_and_modify_register}\n        command-id: some-command-id\n        bitwise-operation: set_bit  # {set_bit, clear_bit, clear_masked_bits, set_masked_bits}\n        index: 0\n        bit: 2\n  - name: StateKind_standby\n    outputs:\n      - output-type: write_multiple_registers_uint32  # {none, write_single_coil, flip_single_coil, write_single_register_uint16, write_single_register_int16, write_multiple_registers_uint32, write_multiple_registers_int32, write_multiple_registers_float32, read_and_modify_register}\n        command-id: some-command-id\n        upper_index: 10\n        lower_index: 11\n        value: 42\n")),Object(a.b)("h3",{id:"schedule-parameters"},"Schedule parameters"),Object(a.b)("p",null,"Each schedule parameter can be mapped to DNP3 Analog Output commands exactly\nlike ",Object(a.b)("a",{parentName:"p",href:"#int32-int64-and-float"},"Int32, Int64 and Float")," fields. Schedules will\nbe executed as described in ",Object(a.b)("a",{parentName:"p",href:"/openfmb.docs/docs/adapter/misc/scheduling"},"Scheduling")," page."),Object(a.b)("pre",null,Object(a.b)("code",{parentName:"pre",className:"language-yaml"},"- scheduleParameter:  # A sequence of schedule parameters w/ enum + value. Each plugin specifies what to do with each enumeration value\n  - scheduleParameterType: ScheduleParameterKind_none\n    output-type: write_single_register_int16  # {none, write_single_register_uint16, write_single_register_int16, write_multiple_registers_uint32, write_multiple_registers_int32, write_multiple_registers_float32}\n    command-id: some-command-id\n    index: 10\n    scale: 1\n  - scheduleParameterType: ScheduleParameterKind_other\n    output-type: write_single_register_int16  # {none, write_single_register_uint16, write_single_register_int16, write_multiple_registers_uint32, write_multiple_registers_int32, write_multiple_registers_float32}\n    command-id: some-command-id\n    index: 11\n    scale: 1\n")))}_.isMDXComponent=!0},133:function(e,t,i){"use strict";i.d(t,"a",(function(){return u})),i.d(t,"b",(function(){return c}));var n=i(0),r=i.n(n);function a(e,t,i){return t in e?Object.defineProperty(e,t,{value:i,enumerable:!0,configurable:!0,writable:!0}):e[t]=i,e}function l(e,t){var i=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),i.push.apply(i,n)}return i}function s(e){for(var t=1;t<arguments.length;t++){var i=null!=arguments[t]?arguments[t]:{};t%2?l(Object(i),!0).forEach((function(t){a(e,t,i[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(i)):l(Object(i)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(i,t))}))}return e}function o(e,t){if(null==e)return{};var i,n,r=function(e,t){if(null==e)return{};var i,n,r={},a=Object.keys(e);for(n=0;n<a.length;n++)i=a[n],t.indexOf(i)>=0||(r[i]=e[i]);return r}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(n=0;n<a.length;n++)i=a[n],t.indexOf(i)>=0||Object.prototype.propertyIsEnumerable.call(e,i)&&(r[i]=e[i])}return r}var p=r.a.createContext({}),_=function(e){var t=r.a.useContext(p),i=t;return e&&(i="function"==typeof e?e(t):s(s({},t),e)),i},u=function(e){var t=_(e.components);return r.a.createElement(p.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return r.a.createElement(r.a.Fragment,{},t)}},m=r.a.forwardRef((function(e,t){var i=e.components,n=e.mdxType,a=e.originalType,l=e.parentName,p=o(e,["components","mdxType","originalType","parentName"]),u=_(i),m=n,c=u["".concat(l,".").concat(m)]||u[m]||d[m]||a;return i?r.a.createElement(c,s(s({ref:t},p),{},{components:i})):r.a.createElement(c,s({ref:t},p))}));function c(e,t){var i=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var a=i.length,l=new Array(a);l[0]=m;var s={};for(var o in t)hasOwnProperty.call(t,o)&&(s[o]=t[o]);s.originalType=e,s.mdxType="string"==typeof e?e:n,l[1]=s;for(var p=2;p<a;p++)l[p]=i[p];return r.a.createElement.apply(null,l)}return r.a.createElement.apply(null,i)}m.displayName="MDXCreateElement"}}]);